The modifications of LAC:

1 Message Space/Session Key Size: In the round 1 version, the message spaces and session key sizes of three security levels are 256 bits, 384 bits and 512 bits. Now in round 2, we set the message space and session key size to be 256 bits for all of the three security levels. The aim of this modification is to make the comparison of LAC and other schemes easier.

2 Secret/Error Distribution: In the round 1 version, the secret and error vectors are chosen from standard centered binomial distribution. Now in round 2, s,e,r,e_1 are chosen from fixed hamming weight centered binomial distribution. The hamming weight is fixed to the expected value of the standard centered binomial distribution. The aim of this modification is to make LAC immune high hamming CCA attack, in which the adversary can find random vectors with high hamming weight by pre-computation and increase the decryption error rate to a high  level. 

Remark 1: Fixing the hamming weight of the secret and error vectors only brings very small effect to the entropy of theses vectors. For example, for $n=512$ the entropy of $\vec{s}$ from standard centered binomial distribution with the standard deviation of $1/\sqrt{2}$ is $768$. When the hamming weight of $\vec{s}$ is fixed as $256$ with $128$ ones and $128$ minus-ones, its entropy is about $\log (\binom{512}{128}\cdot\binom{384}{128})\approx 758$. So the modification of the secret and error distribution will not affect the security reduction and concrete security evaluation of LAC.
    
Remark 2: It is easy to resist high hamming weight CCA attack by using BCH code that can correct more errors. However, correcting more errors will decrease the efficiency of the decoding algorithm of BCH. Our analysis shows that, we need to correct 30 errors to resist the high hamming weight attacks, and the time cost of decoding is 27 microseconds. When the fixed hamming weight centered binomial distribution is used, we only need to correct 16 errors, and the time cost is 12 microseconds.

3 Error Correction Code: In the round 1 version, we only used BCH for error correction. Now in round 2, we use BCH and D2 together for LAC256. For LAC128 and LAC192, only BCH code is used. The parameter sets of BCH code are also updated, we use [511, 256, 33] for LAC128 and LAC256, [511, 256, 17] for LAC192. The aim of this modification is to make the error correction ability adapt to the new message space/session key size and secret/error distribution of LAC.

4 Ciphertext Compression: In the round 2 version, we remove the lower four bits of c_2. Note that, removing lower bits is a popular compression technique used in lattice cryptography. Since the compression of b and c_1 may affect the security reduction, in LAC only c_2 is compressed which will not affect the security reduction. The aim of this modification is to make LAC more compact.

5 Message Length Counter: In the round 1 version, a message length counter is added to help the decryption algorithm getting the length of the message. Now in the round 2 version, this counter is removed. The length of the message can be directly computed from the length of the ciphertext. Briefly, the dimension of c_2 equals the length of the message plus the length of error correction bits of BCH. The aim of this modification is to make LAC more simple and compact.

6 Constant Time Decoding of BCH: In the round 1 version implementation, we use the code of BCH from https://github.com/jkent/python-bchlib/tree/master/bchlib. Now, we rewrite the decoding algorithm of BCH based on this generic implementation and get a constant time version of BCH. The aim of this modification is to make LAC immune timing attack.