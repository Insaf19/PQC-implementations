//
//  HK17_api.c
//	This file is part of a HK17 Algorithm Implementation
//  Implemented by Matias Teragni - 2017. 
//
//  This files implements the interface dictated by NIST on the file api.h for the HK17 algorithm
//	and adds the required structures to facilitate the internal implementation of that interface
//structures
//	HK_KEM_PK
//		this structure is returned by crypto_kem_keypair, and consumed by crypto_kem_enc.
//		it is composed of a mix of public and private data. Specifically:
//		public
//			OA, OB, RB
//		private
//			m,n,f
//	HK_KEM_SK
//		this structure is returned by crypto_kem_keypair, and consumed by crypto_kem_dec.
//		it is composed of a mix of public and private data. Specifically:
//		public
//			OA
//		private
//			r,s,h
//functions
// crypto_kem_keypair
//    this function creates all the public random data required by the algorithm, the private data for both nodes
//	  and the public token associated with one of the nodes, fitting all of it into the structures required by NIST
// crypto_kem_enc
//    this function takes part of the data generated by crypto_kem_keypair and builds the other public token , 
//	  along with the shared secret to be used in the validation
// crypto_kem_dec
//    this function takes the second public token and calculates the shared secret from the view of the second node
//	  then it returns that data to be validated against the result of crypto_kem_enc

#include "api.h"


#define mod 65521
#define degree 32

typedef struct {
	octonion OA;
	octonion OB;
	octonion RB;
	long long m;
	long long n;
	polynomialTerm f[degree];
}HK_KEM_PK;
typedef struct {
	octonion OA;
	long long r;
	long long s;
	polynomialTerm h[degree];
}HK_KEM_SK;


int crypto_kem_keypair(unsigned char *pk, unsigned char *sk) {
	//PK should be OA OB RB M N F
	//SK should be OA R S H
 
	//private stuff

	HK_KEM_PK * rpk = (HK_KEM_PK *) pk;
	HK_KEM_SK * rsk = (HK_KEM_SK *) sk;


	HK17PrivateKey* aliceKey = buildPrivateKey(degree, mod);

	HK17PrivateKey* bobKey = buildPrivateKey(degree, mod);

	//public shared stuff
	octonion publicOA = buildRandomOctonion(mod);
	octonion publicOB = buildRandomOctonion(mod);

	octonion bobToken = calculateToken(publicOA, publicOB, bobKey);

	rpk->OA = publicOA;
	rpk->OB = publicOB;
	rpk->RB = bobToken;
	rpk->m = aliceKey->m;
	rpk->n = aliceKey->n;
	//copy this maybe
	memcpy(&rpk->f, aliceKey->polynomial, degree * sizeof(polynomialTerm));
	//rpk->f = aliceKey->polynomial;
	free(aliceKey);

	rsk->OA = publicOA;
	rsk->r = bobKey->m;
	rsk->s = bobKey->n;
	//copy this maybe	
	memcpy(&rsk->h, bobKey->polynomial, degree * sizeof(polynomialTerm));
	//rsk->h = bobKey->polynomial;

	return 0;
}

int crypto_kem_enc(unsigned char *ct, unsigned char *ss, const unsigned char *pk)
{ 
	HK_KEM_PK * rpk = (HK_KEM_PK * )pk;
	//TODO: avoid doing this again
	HK17PrivateKey* aliceKey = (HK17PrivateKey*)malloc(sizeof(HK17PrivateKey));
	aliceKey->m = rpk->m;
	aliceKey->n = rpk->n;
	aliceKey->module = mod;
	aliceKey->polynomialDegree = degree;
	aliceKey->polynomial = &rpk->f[0];


	octonion RA = calculateToken(rpk->OA, rpk->OB, aliceKey);
	memcpy(ct, &RA, sizeof(octonion));

	//session shared knowledge

	octonion SK = calculateToken(rpk->OA, rpk->RB, aliceKey);
	memcpy(ss, &SK, sizeof(octonion));

	return 0;
}
int crypto_kem_dec(unsigned char *ss, const unsigned char *ct, const unsigned char *sk)
{

	octonion RA = { 0 };
	memcpy(&RA, ct, sizeof(octonion));
	HK_KEM_SK * rsk = (HK_KEM_SK *)sk;

	HK17PrivateKey* bobKey = (HK17PrivateKey*)malloc(sizeof(HK17PrivateKey));
	bobKey->m = rsk->r;
	bobKey->n = rsk->s;
	bobKey->module = mod;
	bobKey->polynomialDegree = degree;
	bobKey->polynomial = &rsk->h[0];


	octonion SK = calculateToken(rsk->OA, RA, bobKey);
	memcpy(ss, &SK, sizeof(octonion));

	return 0;
}